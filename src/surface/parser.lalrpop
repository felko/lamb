use crate::surface::lexer::{Token, Error};
use crate::surface::syntax::{Expr, Type, Binding};

grammar<'src>(
    errors: &mut Vec<Error>
);

extern {
    type Error = Error;
    type Location = usize;

    enum Token<'src> {
        "(" => Token::LParen,
        ")" => Token::RParen,
        ":" => Token::Colon,
        "=" => Token::Equal,
        "->" => Token::Arrow,
        "=>" => Token::DoubleArrow,
        "+" => Token::Plus,
        "fun" => Token::Fun,
        "let" => Token::Let,
        "in" => Token::In,
        "Int" => Token::Int,
        "Bool" => Token::Bool,
        Identifier => Token::Identifier(<&'src str>),
        Number => Token::Number(<i32>),
    }
}

Box<T>: Box<T> = T => Box::new(<>);

pub Type: Type<'src> = Type0;

FuncTypeParam: Type<'src> = <Type1> "->";

Type0: Type<'src> = {
    <params: (FuncTypeParam)*> <ret: Box<Type1>> =>
        if params.is_empty() {
            *ret
        } else {
            Type::Func(params, ret)
        },
}

Type1: Type<'src> = {
    "Int" => Type::Int,
    "Bool" => Type::Bool,
    <name: Identifier> => Type::Var(name),
    "(" <Type0> ")" => <>,
}

Annotation: Type<'src> = {
    ":" <t: Type> => t
}

Binding: Binding<'src> = {
    <name: Identifier> => Binding::Inferred(name),
    "(" <name: Identifier> <ann: (Annotation)?> ")" => match ann {
        Some(t) => Binding::Typed(name, t),
        None => Binding::Inferred(name),
    },
}

pub Expr = Expr0;

Expr0: Expr<'src> = {
    "fun" <params: (Binding)+> "=>" <body: Box<Expr0>> => Expr::Abs(params, body),
    "let" <name: Identifier> <params: (Binding)*> <return_type: (Annotation)?> "=" <body: Box<Expr0>> "in" <cont: Box<Expr0>> => Expr::Let {name, params, return_type, body, cont },
    <Expr1>,
}

Expr1: Expr<'src> = {
    <lhs: Box<Expr1>> "+" <rhs: Box<Expr2>> => Expr::Add(lhs, rhs),
    <Expr2>,
}

Expr2: Expr<'src> = {
    <callee: Box<Expr3>> <args: (Expr3)+> => Expr::App(callee, args),
    <Expr3>,
}

Expr3: Expr<'src> = {
    Number => Expr::Lit(<>),
    Identifier => Expr::Var(<>),
    "(" <Expr0> ")" => <>,
}
